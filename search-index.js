var searchIndex = {};
searchIndex['peruse'] = {"items":[[0,"","peruse","Peruse is a basic parser combinator library for Rust.",null,null],[0,"parsers","","",null,null],[3,"ChainedParser","peruse::parsers","A Chained parser contains two parsers that will be used in sequence to\ncreate a tuple of parsed values",null,null],[3,"RepeatParser","","A Parser that repeats the given parser until it encounters an error.  A\nvector of the accumulated parsed values is returned",null,null],[3,"MapParser","","A Parser that uses a closure to map the result of another parser",null,null],[3,"OrParser","","",null,null],[3,"OptionParser","","",null,null],[3,"RecursiveParser","","",null,null],[3,"RepSepParser","","A Parser that will repeatedly parse `rep` and `sep` in sequence until `sep`\nreturns an error.  The accumulated `rep` results are returned.  If `rep`\nreturns an error at any time, the error is escelated.",null,null],[12,"rep","","",0,null],[12,"sep","","",0,null],[12,"min_reps","","",0,null],[3,"OneOfParser","","A Parser that takes a vector of parsers (of the exact same type) and\nreturns the value from the first parser to return a non-error.  This parser\nsolely exists because doing a or b or c or d... ends up crushing rustc",null,null],[3,"BoxedParser","","this parser solely exists to avoid insanely long compile times in rustc.\nWhen you have a fairly large parser, it's best to box it.  Yes we're\nintroducing extra dynamic dispatch, but only on a small amount.  In some\ncases this is the only way to get rustc to not take (literally) a million\nyears!",null,null],[5,"opt","","Create a parser that will return Some if the given parser is successful, None otherwise",null,{"inputs":[{"name":"t"}],"output":{"name":"optionparser"}}],[5,"recursive","","Create a lazily evaluated parser from a function.  This can be used to generate recursive parsers",null,{"inputs":[{"name":"f"}],"output":{"name":"recursiveparser"}}],[5,"repsep","","Create a parser that will repeatedly use the `rep` and `sep` parsers in\nsequence, building a vector of results from `rep`.  This will repeat until\n`sep` returns an error.  If at any point `rep` returns an error, the collected\nvalues are discarded and the error is escelated.",null,{"inputs":[{"name":"a"},{"name":"b"}],"output":{"name":"repsepparser"}}],[5,"one_of","","Create a parser that attempts to use each of the given parsers until one succeeds.  If all the\ngiven parses are literally the exact same type, they can be unboxed, otherwise you'll have to\nbox them using the `boxed` function.",null,{"inputs":[{"name":"vec"}],"output":{"name":"oneofparser"}}],[5,"boxed","","Wrap a boxed parser.  This mostly exists to avoid slow compile times.  Boxing a complex parser into a\ntrait object keep compile times down as the boxed parser is combined with other parsers",null,{"inputs":[{"name":"p"}],"output":{"name":"boxedparser"}}],[6,"ParseResult","","The result of a parser's attempt to parse input data.",null,null],[8,"Parser","","The base trait for any parser.",null,null],[16,"I","","",1,null],[16,"O","","",1,null],[10,"parse","","Attempt to parse an input value into an output value",1,{"inputs":[{"name":"parser"},{"name":"i"}],"output":{"name":"parseresult"}}],[8,"ParserCombinator","","Combinator methods for slice parsers.  In most cases, these methods copy\nthe caller into a higher-order parser",null,null],[11,"then","","Chain this parser with another parser, creating new parser that returns a\ntuple of their results",2,{"inputs":[{"name":"parsercombinator"},{"name":"p"}],"output":{"name":"chainedparser"}}],[11,"then_r","","Chain this parser with another parser, but toss the value from this parser",2,{"inputs":[{"name":"parsercombinator"},{"name":"p"}],"output":{"name":"mapparser"}}],[11,"then_l","","Chain this parser with another parser, but toss the value from the other parser",2,{"inputs":[{"name":"parsercombinator"},{"name":"p"}],"output":{"name":"mapparser"}}],[11,"repeat","","Create a new parser that will repeat this parser until it returns an error",2,{"inputs":[{"name":"parsercombinator"}],"output":{"name":"repeatparser"}}],[11,"map","","Map the value of this parser",2,{"inputs":[{"name":"parsercombinator"},{"name":"f"}],"output":{"name":"mapparser"}}],[11,"or","","Create a disjunction with another parser.  If this parser produces an error, the other parser will be used",2,{"inputs":[{"name":"parsercombinator"},{"name":"p"}],"output":{"name":"orparser"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",3,{"inputs":[{"name":"chainedparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",3,{"inputs":[{"name":"chainedparser"}],"output":{"name":"self"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",4,{"inputs":[{"name":"repeatparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",4,{"inputs":[{"name":"repeatparser"}],"output":{"name":"self"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",5,{"inputs":[{"name":"mapparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",5,{"inputs":[{"name":"mapparser"}],"output":{"name":"self"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",6,{"inputs":[{"name":"orparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",6,{"inputs":[{"name":"orparser"}],"output":{"name":"self"}}],[11,"clone","","",7,{"inputs":[{"name":"optionparser"}],"output":{"name":"optionparser"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",7,{"inputs":[{"name":"optionparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",8,{"inputs":[{"name":"recursiveparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",8,{"inputs":[{"name":"recursiveparser"}],"output":{"name":"self"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",0,{"inputs":[{"name":"repsepparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",0,{"inputs":[{"name":"repsepparser"}],"output":{"name":"self"}}],[11,"clone","","",9,{"inputs":[{"name":"oneofparser"}],"output":{"name":"oneofparser"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",9,{"inputs":[{"name":"oneofparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",10,{"inputs":[{"name":"boxedparser"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"clone","","",10,{"inputs":[{"name":"boxedparser"}],"output":{"name":"self"}}],[0,"slice_parsers","peruse","Slice parsers are parsers designed to work with slices of items.  These parsers work by\nconsuming one or more elements off the beginning of the slice, converting them into an output\ntype, and return the output value along with the rest of the slice.",null,null],[3,"LiteralParser","peruse::slice_parsers","A LiteralParser looks for an exact match of the given item at the beginning",null,null],[12,"literal","","",11,null],[3,"MatchParser","","",null,null],[5,"lit","","Create a parser that only recognizes the given literal value",null,{"inputs":[{"name":"t"}],"output":{"name":"literalparser"}}],[5,"matcher","","Create a parser that matches against the first element in the slice and returns either a Some\nof an output value, or None if the element does not match.  If None is returned the parser will\nreturn an error.",null,{"inputs":[{"name":"f"}],"output":{"name":"matchparser"}}],[6,"SliceParser","","",null,null],[11,"clone","","",11,{"inputs":[{"name":"literalparser"}],"output":{"name":"literalparser"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",11,null],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",12,null],[11,"clone","","",12,{"inputs":[{"name":"matchparser"}],"output":{"name":"self"}}],[0,"string_parsers","peruse","",null,null],[3,"RegexLiteralParser","peruse::string_parsers","A string Parser that attempts to consume the given regex",null,null],[12,"regex","","",13,null],[3,"RegexCapturesParser","","",null,null],[12,"regex","","",14,null],[5,"rlit","","",null,{"inputs":[{"name":"regex"},{"name":"t"}],"output":{"name":"regexliteralparser"}}],[5,"str_lit","","",null,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"regexliteralparser"}}],[5,"capture","","",null,{"inputs":[{"name":"str"},{"name":"f"}],"output":{"name":"regexcapturesparser"}}],[6,"StringParser","","",null,null],[11,"clone","","",13,{"inputs":[{"name":"regexliteralparser"}],"output":{"name":"regexliteralparser"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",13,{"inputs":[{"name":"regexliteralparser"},{"name":"str"}],"output":{"name":"parseresult"}}],[6,"I","","",null,null],[6,"O","","",null,null],[11,"parse","","",14,{"inputs":[{"name":"regexcapturesparser"},{"name":"str"}],"output":{"name":"parseresult"}}],[11,"clone","","",14,{"inputs":[{"name":"regexcapturesparser"}],"output":{"name":"self"}}]],"paths":[[3,"RepSepParser"],[8,"Parser"],[8,"ParserCombinator"],[3,"ChainedParser"],[3,"RepeatParser"],[3,"MapParser"],[3,"OrParser"],[3,"OptionParser"],[3,"RecursiveParser"],[3,"OneOfParser"],[3,"BoxedParser"],[3,"LiteralParser"],[3,"MatchParser"],[3,"RegexLiteralParser"],[3,"RegexCapturesParser"]]};
searchIndex['regex'] = {"items":[[0,"","regex","This crate provides a native implementation of regular expressions that is\nheavily based on RE2 both in syntax and in implementation. Notably,\nbackreferences and arbitrary lookahead/lookbehind assertions are not\nprovided. In return, regular expression searching provided by this package\nhas excellent worst case performance. The specific syntax supported is\ndocumented further down.",null,null],[3,"Error","","Error corresponds to something that can go wrong while parsing\na regular expression.",null,null],[12,"pos","","The *approximate* character index of where the error occurred.",0,null],[12,"msg","","A message describing the error.",0,null],[3,"Captures","","Captures represents a group of captured strings for a single match.",null,null],[3,"SubCaptures","","An iterator over capture groups for a particular match of a regular\nexpression.",null,null],[3,"SubCapturesPos","","An iterator over capture group positions for a particular match of a\nregular expression.",null,null],[3,"SubCapturesNamed","","An Iterator over named capture groups as a tuple with the group\nname and the value.",null,null],[3,"FindCaptures","","An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.",null,null],[3,"FindMatches","","An iterator over all non-overlapping matches for a particular string.",null,null],[3,"NoExpand","","NoExpand indicates literal string replacement.",null,null],[3,"RegexSplits","","Yields all substrings delimited by a regular expression match.",null,null],[3,"RegexSplitsN","","Yields at most `N` substrings delimited by a regular expression match.",null,null],[4,"Regex","","A compiled regular expression",null,null],[5,"quote","","Escapes all regular expression meta characters in `text`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"is_match","","Tests if the given regular expression matches somewhere in the text given.",null,{"inputs":[{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"fmt","","Shows the original regular expression.",1,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Shows the original regular expression.",1,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"from_str","","Attempts to parse a string into a regular expression",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"new","","Compiles a dynamic regular expression. Once compiled, it can be\nused repeatedly to search, split or replace text in a string.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if the regex matches the string given.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"bool"}}],[11,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findmatches"}}],[11,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter` (except it\nyields information about submatches).",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findcaptures"}}],[11,"split","","Returns an iterator of substrings of `text` delimited by a match\nof the regular expression.\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.",1,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"regexsplits"}}],[11,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.)\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.\nThe remainder of the string that is not split will be the last element\nin the iterator.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"}],"output":{"name":"regexsplitsn"}}],[11,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches'\n`Captures` and returns the replaced string.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replace_all","","Replaces all non-overlapping matches in `text` with the\nreplacement provided. This is the same as calling `replacen` with\n`limit` set to `0`.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",1,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"},{"name":"r"}],"output":{"name":"string"}}],[11,"as_str","","Returns the original string of this regex.",1,{"inputs":[{"name":"regex"}],"output":{"name":"str"}}],[11,"reg_replace","","",2,{"inputs":[{"name":"noexpand"},{"name":"captures"}],"output":{"name":"cow"}}],[11,"next","","",3,{"inputs":[{"name":"regexsplits"}],"output":{"name":"option"}}],[11,"next","","",4,{"inputs":[{"name":"regexsplitsn"}],"output":{"name":"option"}}],[11,"pos","","Returns the start and end positions of the Nth capture group.\nReturns `None` if `i` is not a valid capture group or if the capture\ngroup did not match anything.\nThe positions returned are *always* byte indices with respect to the\noriginal string matched.",5,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Returns the matched string for the capture group `i`.  If `i` isn't\na valid capture group or didn't match anything, then `None` is\nreturned.",5,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn't a valid capture group or didn't match anything, then\n`None` is returned.",5,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"option"}}],[11,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcaptures"}}],[11,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturespos"}}],[11,"iter_named","","Creates an iterator of all named groups as an tuple with the group\nname and the value. The iterator returns these values in arbitrary\norder.",5,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturesnamed"}}],[11,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",5,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"string"}}],[11,"len","","Returns the number of captured groups.",5,{"inputs":[{"name":"captures"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns if there are no captured groups.",5,{"inputs":[{"name":"captures"}],"output":{"name":"bool"}}],[11,"next","","",6,{"inputs":[{"name":"subcaptures"}],"output":{"name":"option"}}],[11,"next","","",7,{"inputs":[{"name":"subcapturespos"}],"output":{"name":"option"}}],[11,"next","","",8,{"inputs":[{"name":"subcapturesnamed"}],"output":{"name":"option"}}],[11,"next","","",9,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"next","","",10,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[8,"Replacer","","Replacer describes types that can be used to replace matches in a string.",null,null],[10,"reg_replace","","Returns a possibly owned string that is used to replace the match\ncorresponding to the `caps` capture group.",11,{"inputs":[{"name":"replacer"},{"name":"captures"}],"output":{"name":"cow"}}]],"paths":[[3,"Error"],[4,"Regex"],[3,"NoExpand"],[3,"RegexSplits"],[3,"RegexSplitsN"],[3,"Captures"],[3,"SubCaptures"],[3,"SubCapturesPos"],[3,"SubCapturesNamed"],[3,"FindCaptures"],[3,"FindMatches"],[8,"Replacer"]]};
initSearch(searchIndex);
