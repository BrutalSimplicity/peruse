initSidebarItems({"fn":[["boxed","Wrap a boxed parser.  This mostly exists to avoid slow compile times.  Boxing a complex parser into a trait object keep compile times down as the boxed parser is combined with other parsers"],["one_of","Create a parser that attempts to use each of the given parsers until one succeeds.  If all the given parses are literally the exact same type, they can be unboxed, otherwise you'll have to box them using the `boxed` function."],["opt","Create a parser that will return Some if the given parser is successful, None otherwise"],["recursive","Create a lazily evaluated parser from a function.  This can be used to generate recursive parsers"],["repsep","Create a parser that will repeatedly use the `rep` and `sep` parsers in sequence, building a vector of results from `rep`.  This will repeat until `sep` returns an error.  If at any point `rep` returns an error, the collected values are discarded and the error is escelated."]],"struct":[["BoxedParser","this parser solely exists to avoid insanely long compile times in rustc. When you have a fairly large parser, it's best to box it.  Yes we're introducing extra dynamic dispatch, but only on a small amount.  In some cases this is the only way to get rustc to not take (literally) a million years!"],["ChainedParser","A Chained parser contains two parsers that will be used in sequence to create a tuple of parsed values"],["MapParser","A Parser that uses a closure to map the result of another parser"],["OneOfParser","A Parser that takes a vector of parsers (of the exact same type) and returns the value from the first parser to return a non-error.  This parser solely exists because doing a or b or c or d... ends up crushing rustc"],["OptionParser",""],["OrParser",""],["RecursiveParser",""],["RepSepParser","A Parser that will repeatedly parse `rep` and `sep` in sequence until `sep` returns an error.  The accumulated `rep` results are returned.  If `rep` returns an error at any time, the error is escelated."],["RepeatParser","A Parser that repeats the given parser until it encounters an error.  A vector of the accumulated parsed values is returned"]],"trait":[["Parser","The base trait for any parser."],["ParserCombinator","Combinator methods for slice parsers.  In most cases, these methods copy the caller into a higher-order parser"]],"type":[["ParseResult","The result of a parser's attempt to parse input data."]]});